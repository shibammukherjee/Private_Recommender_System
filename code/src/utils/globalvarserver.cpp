#pragma once
#include <cstddef>
#include <iostream>
#include <vector>
#include "seal/seal.h"

using namespace std;
using namespace seal;

vector<uint64_t> randomservershareplusdatapointdimensions;    // Distance share for the server that was ADDED plus the datapoint dimensions, that is the Bi^2
// multiple of same if the data structure requires, like in doramclusterpointstopk distance calculation
vector<Ciphertext> cipherdistanceshare;                 // Encrypted distance, this contains the distance of each item in each coeffs
vector<uint64_t> id;                                    // Continious/Random IDs generated by server for each distance (represnets the labels of the datapoints)

vector<uint64_t> uniformrandomshuffleindexlist;         // The temporary index used to store the
// ... shuffled index of the dataset to perfom random shuffle

vector<uint64_t> stashrandomdistancesubstract;     // stores the random value to substract with the distance for the stash and the group process in shareddistancetopk.cpp
vector<uint64_t> stashrandomidxor;                 // stores the random value to xor with the cluster id for the stash and the group process in shareddistancetopk.cpp

vector<uint64_t> randomstashidxor;                      // stores the random value to xor with the id for the stash process
vector<uint64_t> randomstashdistancesubstract;          // stores the random value to substract with the id for the stash process

vector<uint64_t> doramrandomdistancesubstract;          // stores the random value to substract with the distance for the doram process in doramreadclusterstopk.cpp
vector<uint64_t> doramrandomidxor;                      // stores the random value to xor with the datapoint id for the doram process in doramreadclusterstopk.cpp

vector<uint64_t> gcstashplusdoramdatapointdistancesubstract; // Contains the gcstashdistanceshare and gcdoramtopkdatapointdistanceshare together
vector<uint64_t> gcstashplusdoramdatapointidxor;           // Contains the gcstashdistanceshare and gcdoramtopkdatapointidshare together

//  Data structure of stashdataset --- vector shape --- (number of dimension, number of points)
// This and the other below were made like this because there was a problem in the file parsing unfortunately and I was too laze to think more
//  X   Y   Z ----> first vector with 3 elements
//  x1  y1  z1 ----> stash element first       
//  x2  y2  z2 ----> stash element second
vector<vector<uint64_t>> stashdataset;                  // Contains all the dataset points which belong to the cluster
// ... which belong to the groups with less than minimum number of clusters
vector<uint64_t> stashlabels;                           // contains the uint labels of each points of the dataset

//  Data structure of allgroupdataset --- vector shape --- (number of groups, number of dimension, number of points)
vector<vector<vector<uint64_t>>> allgroupclusterdataset;       // Contains the points of the cluster centers of the accepted groups
//grpno clusterlabels
vector<vector<uint64_t>> allgroupclusterlabels;             // Contians the uint labels of the clusters, 
// **** IMPORTANT: THIS IS ALWAYS USED IN THE FOR-LOOP TO GET THE NUMBER OF CLUSTERS IN A GROUP INSTEAD OF 
// ... allgroupclusterdataset, BECAUSE THE SECOND VECTOR IS ACTUALLY THE DIMENSION VECTOR AND NOT SOMETHING 
// ... RELATED TO THE NUMBER OF CLUSTERS, THE THIRD VECTOR CAN BE USED BECAUSE IT REPRESENTS THE NUMBER OF 
// ... CLUSTERS, BUT THIS WOULD LOOK UGLY

//grpno  clusterindex
vector<vector<uint64_t>> doramgroupclusterid;     // This contains the random ids of the clusters of the doram dataset                                                        

//                                                           1..T           1..N              3(is constant)     MAXIMUM_DORAM_CLUSTER_SIZE
//  Data structure of doramdataset --- vector shape --- (number of group, number of cluster, number of dimension, number of points)
vector<vector<vector<vector<uint64_t>>>> doramshuffledataset;  // Contains all the SHUFFLED clusters and their datapoints which will be qualified to be in 
// ... the group along with the dummy items to reach the max size
//groupno  clusterno  itemlabels
vector<vector<vector<uint64_t>>> doramshufflelabels;    // Contains all the SHUFFLED clusters (and their item labels) which will be qualified to be in 
// ... the group along with the dummy items to reach the max size


//groupno clusterno itemno
vector<vector<vector<uint64_t>>> doramreadrandomshare;          // This is the random R this is xored to the DB in the GC before sending the output to the client
vector<uint64_t> doramreadrandomshareflat;                      // A flattened version of the above vector doramreadrandomshare

//  [grpno]   [cluster seed]
vector<vector<uint64_t>> seed; // Stores here the seed to generate the random shares of the server which are
// ... xored/added to the cluster items and labels.

uint64_t seedshareconst;  // This is the super secret constant that is xored with the seed to make it a share before sending to the client.

// clusterno randomshares
vector<vector<uint64_t>> kreyviumserverrandomshares; // This is the kreyvium server share which is used to secret share the kreyvium stream
// generated from the random seed for a particular cluster.
